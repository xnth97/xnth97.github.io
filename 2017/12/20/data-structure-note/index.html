<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>数据结构笔记 | NOWHERE</title>
  <meta name="author" content="Yubo Qin" />
  <meta name="description" content="一些碎碎念" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/images/blog/favicon/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/blog/favicon/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/blog/favicon/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/blog/favicon/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon-precomposed" sizes="60x60" href="/images/blog/favicon/apple-touch-icon-60x60.png" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/images/blog/favicon/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/images/blog/favicon/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/images/blog/favicon/apple-touch-icon-152x152.png" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-196x196.png" sizes="196x196" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-16x16.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-128.png" sizes="128x128" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200;300;400;500;600;700;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">

  <meta name="generator" content="NOWHERE">

  
  
  
</head>


<body class="post-template">

  <!-- Generated using IconMoon -->
<svg aria-hidden="true" style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <defs>
  <symbol id="icon-facebook2" viewBox="0 0 32 32">
  <path d="M29 0h-26c-1.65 0-3 1.35-3 3v26c0 1.65 1.35 3 3 3h13v-14h-4v-4h4v-2c0-3.306 2.694-6 6-6h4v4h-4c-1.1 0-2 0.9-2 2v2h6l-1 4h-5v14h9c1.65 0 3-1.35 3-3v-26c0-1.65-1.35-3-3-3z"></path>
  </symbol>
  <symbol id="icon-twitter" viewBox="0 0 32 32">
  <path d="M32 7.075c-1.175 0.525-2.444 0.875-3.769 1.031 1.356-0.813 2.394-2.1 2.887-3.631-1.269 0.75-2.675 1.3-4.169 1.594-1.2-1.275-2.906-2.069-4.794-2.069-3.625 0-6.563 2.938-6.563 6.563 0 0.512 0.056 1.012 0.169 1.494-5.456-0.275-10.294-2.888-13.531-6.862-0.563 0.969-0.887 2.1-0.887 3.3 0 2.275 1.156 4.287 2.919 5.463-1.075-0.031-2.087-0.331-2.975-0.819 0 0.025 0 0.056 0 0.081 0 3.181 2.263 5.838 5.269 6.437-0.55 0.15-1.131 0.231-1.731 0.231-0.425 0-0.831-0.044-1.237-0.119 0.838 2.606 3.263 4.506 6.131 4.563-2.25 1.762-5.075 2.813-8.156 2.813-0.531 0-1.050-0.031-1.569-0.094 2.913 1.869 6.362 2.95 10.069 2.95 12.075 0 18.681-10.006 18.681-18.681 0-0.287-0.006-0.569-0.019-0.85 1.281-0.919 2.394-2.075 3.275-3.394z"></path>
  </symbol>
  <symbol id="icon-sina-weibo" viewBox="0 0 32 32">
  <path d="M13.444 28.063c-5.3 0.525-9.875-1.875-10.219-5.35-0.344-3.481 3.675-6.719 8.969-7.244 5.3-0.525 9.875 1.875 10.213 5.35 0.35 3.481-3.669 6.725-8.963 7.244zM24.038 16.519c-0.45-0.137-0.762-0.225-0.525-0.819 0.512-1.287 0.563-2.394 0.006-3.188-1.038-1.481-3.881-1.406-7.137-0.037 0 0-1.025 0.444-0.762-0.363 0.5-1.613 0.425-2.956-0.356-3.738-1.769-1.769-6.469 0.069-10.5 4.1-3.013 3.006-4.763 6.213-4.763 8.981 0 5.288 6.787 8.506 13.425 8.506 8.7 0 14.494-5.056 14.494-9.069 0-2.431-2.044-3.806-3.881-4.375z"></path>
  <path d="M29.819 6.831c-2.1-2.331-5.2-3.219-8.063-2.612v0c-0.663 0.144-1.081 0.794-0.938 1.45 0.144 0.662 0.788 1.081 1.45 0.938 2.038-0.431 4.238 0.2 5.731 1.856s1.9 3.912 1.256 5.888v0c-0.206 0.644 0.144 1.331 0.788 1.544 0.644 0.206 1.331-0.144 1.544-0.787v-0.006c0.9-2.762 0.331-5.938-1.769-8.269z"></path>
  <path d="M26.587 9.75c-1.025-1.137-2.538-1.569-3.925-1.269-0.569 0.119-0.931 0.688-0.813 1.256 0.125 0.569 0.688 0.931 1.25 0.806v0c0.681-0.144 1.419 0.069 1.919 0.619 0.5 0.556 0.637 1.313 0.419 1.975v0c-0.175 0.55 0.125 1.15 0.681 1.331 0.556 0.175 1.15-0.125 1.331-0.681 0.438-1.356 0.163-2.906-0.863-4.037z"></path>
  <path d="M13.738 21.769c-0.188 0.319-0.594 0.469-0.912 0.337-0.319-0.125-0.412-0.488-0.231-0.794 0.188-0.306 0.581-0.456 0.894-0.337 0.313 0.113 0.425 0.469 0.25 0.794zM12.044 23.931c-0.512 0.819-1.613 1.175-2.438 0.8-0.813-0.369-1.056-1.319-0.544-2.119 0.506-0.794 1.569-1.15 2.387-0.806 0.831 0.356 1.1 1.3 0.594 2.125zM13.969 18.144c-2.519-0.656-5.369 0.6-6.463 2.819-1.119 2.262-0.037 4.781 2.506 5.606 2.637 0.85 5.75-0.456 6.831-2.894 1.069-2.394-0.262-4.85-2.875-5.531z"></path>
  </symbol>
  <symbol id="icon-linkedin" viewBox="0 0 32 32">
  <path d="M29 0h-26c-1.65 0-3 1.35-3 3v26c0 1.65 1.35 3 3 3h26c1.65 0 3-1.35 3-3v-26c0-1.65-1.35-3-3-3zM12 26h-4v-14h4v14zM10 10c-1.106 0-2-0.894-2-2s0.894-2 2-2c1.106 0 2 0.894 2 2s-0.894 2-2 2zM26 26h-4v-8c0-1.106-0.894-2-2-2s-2 0.894-2 2v8h-4v-14h4v2.481c0.825-1.131 2.087-2.481 3.5-2.481 2.488 0 4.5 2.238 4.5 5v9z"></path>
  </symbol>
  </defs>
  </svg>

  <header class="site-head"  style="background-image: url(/images/blog/cover.jpg)" >
  <div class="vertical">
    <div class="site-head-content inner">
       <a class="blog-logo"
        href="/"><img src="/images/blog/avatar.png"
          alt="Blog Logo" /></a> 
      <h1 class="blog-title">NOWHERE</h1>
      <h2 class="blog-description">一些碎碎念</h2>
    </div>

    
  </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2017-12-20T05:35:15.000Z" itemprop="datePublished">
          2017-12-19
      </time>
    
    
    | 
    <a href='/tags/coding/'>coding</a>,
    
    <a href='/tags/note/'>note</a>
    
    
</span>
    <h1 class="post-title">数据结构笔记</h1>
    <section class="post-content">
      <p>这学期感觉 Terry 的 Data Structures for Application Developers 对我帮助巨大。毕竟非科班出身，很多概念都是一知半解。第一天上课的时候，Terry 掏出了一把小锤子，尝试用它干各种事情。大家哈哈大笑的时候，Terry 说，</p>
<blockquote>
<p>This is exactly what you are doing. You have lots of tools, but you always use ArrayList.</p>
</blockquote>
<p>这门课学下来，Terry 深入浅出地讲解了各种基础算法和数据结构、它们背后的实现、以及如何去选择，上完课的时候真的让我有些醍醐灌顶的感觉。最后一节课下课前，Terry 又说，</p>
<blockquote>
<p>Now you know your tools. Use them wisely.</p>
</blockquote>
<p>这里就来梳理一下我们手中的 tools。</p>
<h1 id="Array-ArrayList-LinkedList"><a href="#Array-ArrayList-LinkedList" class="headerlink" title="Array, ArrayList, LinkedList"></a>Array, ArrayList, LinkedList</h1><h2 id="Array-与-Linear-Search"><a href="#Array-与-Linear-Search" class="headerlink" title="Array 与 Linear Search"></a>Array 与 Linear Search</h2><p>Java 中的数组（没记错的话 C 也是）长度是固定的，即数组一旦创建无法改变大小，所以数组的 <code>length</code> 是 immutable field。如果需要改变，只能创建一个新的更大的数组然后调用 <code>System.arraycopy()</code> 复制。在内存中，假设我们有数组 <code>int array[]</code>，其中 <code>array[0]</code> 的地址是 0x200，那么 <code>array[2]</code> 的地址就是 0x200 + 2 * 4（Java 中 int 是 4 bytes）= 0x208，因此通过下标获取数组中的某个元素可以在常数时间内完成（直接计算地址）。如果用 C 表示的话，那就是 <code>array[2]</code> 和 <code>*(array + 2)</code> 是完全一样的。</p>
<p>假设我们需要在 Array 中找到一个值并删除，一种简单的思路当然是遍历数组总会找到的，这就是 linear search 或 sequential search，一种最简单的搜索算法。同时，在 worst-case 下，它的运行时间也是 O(n) 的，因为可能需要遍历所有 n 个元素。</p>
<h2 id="ArrayList-与-Binary-Search"><a href="#ArrayList-与-Binary-Search" class="headerlink" title="ArrayList 与 Binary Search"></a>ArrayList 与 Binary Search</h2><p>Java 中的 ArrayList 提供了诸如 <code>add()</code>，<code>set()</code> 一类的操作，看起来像是能够改变数组的长度。实际上，ArrayList 底层有一个 Array 数据结构，在每次执行 <code>add()</code> 方法前，会先执行 <code>ensureCapacity()</code> 方法去确保当前持有的 Array 能够有足够的空间。如果没有的话，ArrayList 会创建一个新的更大的数组，然后把旧数组的所有内容复制过来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">        Object oldData[] = elementData;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; minCapacity) &#123;</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在计算 <code>newCapacity</code> 时的 + 1，这是为了保证在 <code>oldCapacity == 0</code> 的时候也能够按照我们预期的执行。</p>
<p>因此，ArrayList 频繁执行 <code>add()</code> 会造成时间复杂度显著的增加，原因在于一般情况下 <code>add()</code> 可以在常数时间完成，然而一旦触发数组复制，需要消耗和原数组长度线性相关的时间去执行复制。因此，不断调用 ArrayList 的 <code>add()</code>，消耗的时间曲线类似于这样：</p>
<p><img src="/images/171219/1.png"><br><br>这就是 ArrayList 的 latency issue。还要注意，在调用 <code>remove()</code> 的时候，由于 Array 不允许内部出现空，因此 ArrayList 需要把内部数组里待删除元素之后的元素全部左移，而且不像 <code>add()</code> 仅会在特定次数时触发数组复制，每次 <code>remove()</code> 都会导致元素移动，因此是非常效率低下的。</p>
<p>对于一个排好序的数组，除了 linear search，一个更好的选择是 binary search。它的思路是每次比较数组正中间的值，如果大于中间值，则对右半边数组继续搜索，否则在左半边搜索。Binary search 大大减少了搜索所需要的时间复杂度，可以达到 O(log n)。</p>
<p>Java 部分的实现在 <a target="_blank" rel="noopener" href="https://github.com/xnth97/Data-Structure-Notes/tree/master/DataStructure/src">这里</a>。Swift 部分的实现在 <a target="_blank" rel="noopener" href="https://github.com/xnth97/Data-Structure-Notes/tree/master/DataStructureSwift/DataStructureSwift">这里</a>。向现实面试低头，正在逐步把这篇笔记用 Python 实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">data: [<span class="built_in">int</span>], key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    lower_bound = <span class="number">0</span></span><br><span class="line">    upper_bound = <span class="built_in">len</span>(data) - <span class="number">1</span></span><br><span class="line">    mid = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> lower_bound &gt; upper_bound:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 注意：直接使用 (lowerBound + upperBound) / 2 可能导致超出 int 范围溢出</span></span><br><span class="line">        mid = lower_bound + (upper_bound - lower_bound) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> data[mid] == key:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> data[mid] &lt; key:</span><br><span class="line">            lower_bound = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            upper_bound = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>为了在常数时间内执行 <code>add()</code> 和 <code>remove()</code>，我们提出了 LinkedList 的数据结构。LinkedList 的思想是：一条链表由若干节点构成，每个节点的 next 属性指向它的下一个节点，链表的 head 指向第一个节点，这就是 singly linked list。如果节点还具有 prev 属性指向它的上一个节点，链表还具有 tail 属性指向最后一个节点，这就是一个 doubly linked list。</p>
<p>实现 LinkedList 的数据结构。首先我们需要定义节点的类，把它实现为一个 inner class。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># inner class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, <span class="built_in">next</span></span>):</span></span><br><span class="line">            self.data = data</span><br><span class="line">            self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Swift Note: 注意和 Java 不同，Swift 需要加好 optional。同时参数 T 需要遵守 equatable 才可以使用 == 判断。</p>
</blockquote>
<p>然后实现 SinglyLinkedList 的各个方法。这里如果我们需要插入一个元素，只要找到上一个元素，然后更改对应的引用就可以了；删除同理。因此，链表的插入和删除可以较快完成。同样的，链表并不是连续的数据结构，一个链表的相邻节点可以在内存中相隔很远。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加到链表开头</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_first</span>(<span class="params">self, item</span>):</span></span><br><span class="line">    self.head = self.Node(item, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 添加到链表结尾</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_last</span>(<span class="params">self, item</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">        self.add_first(item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># traverse to find the last element</span></span><br><span class="line">    tmp = self.head</span><br><span class="line">    <span class="keyword">while</span> tmp.<span class="built_in">next</span>:</span><br><span class="line">        tmp = tmp.<span class="built_in">next</span></span><br><span class="line">    tmp.<span class="built_in">next</span> = self.Node(item, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 在后面插♂入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_after</span>(<span class="params">self, key, item</span>):</span></span><br><span class="line">    tmp = self.head</span><br><span class="line">    <span class="keyword">while</span> tmp <span class="keyword">and</span> tmp.data != key:</span><br><span class="line">        tmp = tmp.<span class="built_in">next</span></span><br><span class="line">    tmp.<span class="built_in">next</span> = self.Node(item, tmp.<span class="built_in">next</span>)</span><br><span class="line"><span class="comment"># 在前面插入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_before</span>(<span class="params">self, key, item</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.head:</span><br><span class="line">        <span class="keyword">if</span> self.head.data == key:</span><br><span class="line">            self.add_first(item)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.data != key:</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            prev.<span class="built_in">next</span> = self.Node(item, cur)</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, key</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.head:</span><br><span class="line">        <span class="keyword">if</span> self.head.data == key:</span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.data != key:</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Array 或 ArrayList<ul>
<li>随机访问的数据结构：每一项可以在常数时间内获取</li>
<li>插入和删除时需要消耗大量资源（移位，复制），连续的数据结构</li>
</ul>
</li>
<li>LinkedList<ul>
<li>顺序访问的数据结构：元素只能按照一定顺序访问（next, prev）</li>
<li>链表元素持有数据和对下一个（上一个）元素的引用</li>
<li>插入和删除元素时无需移动元素，只需要更改引用，不连续的数据结构</li>
</ul>
</li>
</ul>
<h1 id="Stack-Queue"><a href="#Stack-Queue" class="headerlink" title="Stack, Queue"></a>Stack, Queue</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈是一种按照后入先出（last-in-first-out, aka LIFO）顺序插入/移除元素的数据结构。栈的使用非常普遍，例如浏览器的历史记录，例如 iOS 中 UINavigationController 就是维护了一个栈。栈最关键的是有两种操作（peek 不关键）：</p>
<ul>
<li>Push：把一个元素压到栈顶</li>
<li>Pop：把栈顶的元素弹出</li>
<li>Peek：返回栈顶元素，无需弹出</li>
</ul>
<p>栈是建立在其它数据结构的基础上的，它的内部可以是数组也可以是链表。比如，我们可以用一个 LinkedList 去实现栈，这样 push 操作可以用 <code>addLast()</code>，pop 操作可以用 <code>removeLast()</code>。栈的 push 和 pop 操作都应该在常数时间内完成。</p>
<p>基于 Python List，栈可以非常简单地实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.array = []</span><br><span class="line">    <span class="comment"># 检查是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.array) == <span class="number">0</span></span><br><span class="line">    <span class="comment"># 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.array.append(item)</span><br><span class="line">    <span class="comment"># 出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.array.pop()</span><br><span class="line">    <span class="comment"># peek</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.array[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列是一种按照先入先出（first-in-first-out, aka FIFO）顺序插入/移除元素的数据结构。队列也非常常见，比如打印机的队列、在星巴克门店的排队。队列主要也有两种操作：</p>
<ul>
<li>Enqueue：把一个元素插入到队列的尾部</li>
<li>Dequeue：把队首元素移除</li>
</ul>
<p>队列也可以建立在其他数据结构基础上，最简单的当然还是 LinkedList，入队即是 <code>addLast()</code>，出队即 <code>removeFirst()</code>。同样的，入队和出队操作也应该在常数时间内完成。</p>
<p>这里给一个基于 Python List 的非常简单的队列实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.array = []</span><br><span class="line">    <span class="comment"># 检查是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.array) == <span class="number">0</span></span><br><span class="line">    <span class="comment"># 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.array.append(item)</span><br><span class="line">    <span class="comment"># 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        val = self.array[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">del</span> self.array[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    <span class="comment"># peek</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek_front</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.array[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><p>哈希表的主要目标是提高<strong>搜索</strong>的速度。回想之前总结的，linear search 可以保证 O(n) 的运行速度，而对一个排好序的数组，binary search 可以达到 O(log n) 的运行速度。在数组中，我们知道根据下标访问元素是 O(1) 的，那么如果我们知道要搜索的值所对应的下标，则搜索速度也将被加快到 O(1)。用来把搜索值和下标对应起来的函数就是哈希函数。一个良好的哈希函数应该有以下特点：</p>
<ul>
<li>能够快速计算</li>
<li>在下标范围内均匀分布</li>
</ul>
<p>假设我们的哈希函数是取 4 的余数，这样对于 5 和 65 我们会得到相同的哈希值 1。对不同元素计算出相同哈希值叫做发生了 collision（碰撞？），解决 collision 主要有以下方法：</p>
<ul>
<li>Open addressing<ul>
<li>Linear probing：发生 collision 后，直接继续向下找，直到找到数组中一个空的地方可以存放数据。需要注意的是，由于数组长度是不可变的，因此我们定义一个概念叫做 load factor（元素个数/数组长度），如果 load factor 超过某个阈值，我们就创建一个更大的数组，重新计算哈希值并排列元素。</li>
<li>Quadratic probing：利用一个固定的步长去做 secondary clustering。</li>
<li>Double hashing：首先计算哈希值，其次利用哈希值计算步长。通常使用的公式是 s = 1 + (k % (m−2))，其中 s 为步长，k 为第一步计算的哈希值，m 为数组长度。</li>
</ul>
</li>
<li>Closed addressing<ul>
<li>Separate chaining：对于每一个哈希值，不再指向数组中确定的值，而是指向一个链表，具有相同哈希值的元素均存储在哈希值对应的链表中。</li>
</ul>
</li>
</ul>
<h2 id="HashTable-1"><a href="#HashTable-1" class="headerlink" title="HashTable"></a>HashTable</h2><p>我们根据 linear probing 来处理 collision，用数组作为哈希表的底层数据结构。首先实现哈希表数据结构和 inner class：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, initial_capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="comment"># inner data structure</span></span><br><span class="line">        self.hash_array = [<span class="literal">None</span>] * initial_capacity</span><br><span class="line">        <span class="comment"># item to mark as deleted</span></span><br><span class="line">        self.DELETED = self.DataItem(<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 其他方法在这里实现</span></span><br><span class="line">    <span class="comment"># inner class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataItem</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span></span><br><span class="line">            self.key = key</span><br></pre></td></tr></table></figure>

<p>然后我们实现关键的哈希函数，这里我们简单地使用取模。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> key % <span class="built_in">len</span>(self.hash_array)</span><br></pre></td></tr></table></figure>

<p>接下来我们实现搜索、删除和插入，核心思路都是计算 key 的哈希值，如果不对就继续向下找。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">    hash_val = self.__hash_func(key)</span><br><span class="line">    <span class="keyword">while</span> self.hash_array[hash_val]:</span><br><span class="line">        <span class="keyword">if</span> self.hash_array[hash_val].key == key:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        hash_val += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 每次都取模防止溢出</span></span><br><span class="line">        hash_val %= <span class="built_in">len</span>(self.hash_array)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    hash_val = self.__hash_func(key)</span><br><span class="line">    <span class="keyword">while</span> self.hash_array[hash_val]:</span><br><span class="line">        <span class="keyword">if</span> self.hash_array[hash_val].key == key:</span><br><span class="line">            val = self.hash_array[hash_val].key</span><br><span class="line">            self.hash_array[hash_val] = self.DELETED</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        hash_val += <span class="number">1</span></span><br><span class="line">        hash_val %= <span class="built_in">len</span>(self.hash_array)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span></span><br><span class="line">    item = self.DataItem(key)</span><br><span class="line">    hash_val = self.__hash_func(key)</span><br><span class="line">    <span class="keyword">while</span> self.hash_array[hash_val] <span class="keyword">and</span> self.hash_array[hash_val].key != <span class="number">-1</span>:</span><br><span class="line">        hash_val += <span class="number">1</span></span><br><span class="line">        hash_val %= <span class="built_in">len</span>(self.hash_array)</span><br><span class="line">    self.hash_array[hash_val] = item</span><br></pre></td></tr></table></figure>

<h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><h2 id="啥是二叉树"><a href="#啥是二叉树" class="headerlink" title="啥是二叉树"></a>啥是二叉树</h2><p>我们知道，在排好序的数组中，binary search 可以达到 O(log n) 的搜索速度，但插入和删除很慢。在 LinkedList 中可以达到 O(1) 的插入和删除速度，但需要 O(n) 去搜索。如何把两种数据结构的优点结合起来呢？答案就是树，这里我们具体讨论二叉树。</p>
<p>一棵树具有以下结构：</p>
<ul>
<li>Root：树顶端的节点。</li>
<li>Parent：当一个节点（除了根）具有一条向上的边连接另一个节点时，这里上面的节点就称为父节点。</li>
<li>Child：同上，下面那个节点就称为子节点。</li>
<li>Leaf：没有任何子节点的节点称为叶。一棵树中只有一个根，但可以有很多个叶节点。</li>
<li>Level/Height：一个节点到树的根的层级数称为这个节点的 level。</li>
</ul>
<p><img src="/images/171219/2.png"></p>
<p>关于二叉树有以下几个概念：</p>
<ul>
<li>二叉树：二叉树的节点包括它携带的数据、left（对左子节点的引用）和 right（对右子节点的引用）。换句话说，二叉树里的每个节点最多只有两个子节点。</li>
<li>满二叉树：每个节点只有 0 个或 2 个节点。</li>
<li>完全二叉树：一棵每一行从左到右都完全具有节点的二叉树，最底一行可以例外，但也必须从左到右不能有间隔。</li>
<li>二叉搜索树：对于每个有键 k 的节点，它的左子树里的每个节点的键都必须小于 k，而它右子树里的每个节点的键都必须大于 k（不允许重复键）。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里实现的是二叉搜索树。首先实现基本数据结构和节点的数据结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># other method goes here</span></span><br><span class="line">    <span class="comment"># inner class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">float</span></span>):</span></span><br><span class="line">            self.key = key</span><br><span class="line">            self.value = value</span><br><span class="line">            self.left = <span class="literal">None</span></span><br><span class="line">            self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>搜索方法根据 binary search tree 的特性实现，复杂度为 O(log n)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    current = self.root</span><br><span class="line">    <span class="keyword">while</span> current.key != key:</span><br><span class="line">        <span class="keyword">if</span> current.key &lt; key:</span><br><span class="line">            current = current.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = current.left</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>要插入一个节点，首先还是需要搜索到节点在树中的位置，然后通过修改引用插入到树中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">float</span></span>):</span></span><br><span class="line">    new_node = self.Node(key, value)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">        self.root = new_node</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    parent = self.root</span><br><span class="line">    current = self.root</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> current.key == key:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        parent = current</span><br><span class="line">        <span class="keyword">if</span> current.key &lt; key:</span><br><span class="line">            current = current.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current:</span><br><span class="line">                parent.right = new_node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = current.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current:</span><br><span class="line">                parent.left = new_node</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>而要删除一个节点，我们需要分别考虑以下几种情况：</p>
<ul>
<li>要删除的节点不在树中</li>
<li>要删除的节点是叶节点</li>
<li>要删除的节点有一个子节点<ul>
<li>只有左子节点</li>
<li>只有右子节点</li>
</ul>
</li>
<li>要删除的节点有两个子节点</li>
</ul>
<p>首先我们考虑节点未找到的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    parent = self.root</span><br><span class="line">    current = self.root</span><br><span class="line">    is_left_child = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> current.key != key:</span><br><span class="line">        parent = current</span><br><span class="line">        <span class="keyword">if</span> current.key &gt; key:</span><br><span class="line">            is_left_child = <span class="literal">True</span></span><br><span class="line">            current = current.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            is_left_child = <span class="literal">False</span></span><br><span class="line">            current = current.right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current:</span><br><span class="line">            <span class="keyword">return</span> self.root</span><br></pre></td></tr></table></figure>

<p>接下来考虑节点是一个叶节点（即没有子节点），如果该节点是父节点的左子节点，则直接将父节点的左子节点设为 nil，否则把右子节点置空。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># case 2: a leaf</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> current.left <span class="keyword">and</span> <span class="keyword">not</span> current.right:</span><br><span class="line">    <span class="keyword">if</span> current == self.root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> is_left_child:</span><br><span class="line">        parent.left = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>然后考虑节点只有一个子节点的情况：如果该节点是父节点的左子节点，则将父节点的左子节点设为自己的子节点；否则将父节点的右子节点设为自己的子节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># case 3: one child</span></span><br><span class="line"><span class="comment"># only has left child</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> current.right:</span><br><span class="line">    <span class="keyword">if</span> current == self.root:</span><br><span class="line">        <span class="keyword">return</span> current.left</span><br><span class="line">    <span class="keyword">if</span> is_left_child:</span><br><span class="line">        parent.left = current.left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent.right = current.left</span><br><span class="line"><span class="comment"># only has right child</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> current.left:</span><br><span class="line">    <span class="keyword">if</span> current == self.root:</span><br><span class="line">        <span class="keyword">return</span> current.right</span><br><span class="line">    <span class="keyword">if</span> is_left_child:</span><br><span class="line">        parent.left = current.right</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent.right = current.right</span><br></pre></td></tr></table></figure>

<p>最后考虑节点具有两个子节点的情况。这时我们不能简单地更改引用了，我们需要找到这个节点的“继任者”，来代替被删除的节点在树中的位置。一般来说，继任者节点就是在待删除节点右子树中具有最小 key 的节点。我们首先实现寻找继任者的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get_successor</span>(<span class="params">self, to_delete: self.Node</span>) -&gt; self.Node:</span></span><br><span class="line">    <span class="comment"># find the minimum node in to_delete&#x27;s right subtree</span></span><br><span class="line">    parent = to_delete</span><br><span class="line">    successor = to_delete</span><br><span class="line">    current = to_delete.right</span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        parent = successor</span><br><span class="line">        successor = current</span><br><span class="line">        current = current.left</span><br><span class="line">    <span class="keyword">if</span> successor != to_delete.right:</span><br><span class="line">        parent.left = successor.right</span><br><span class="line">        successor.right = to_delete.right</span><br><span class="line">    <span class="keyword">return</span> successor</span><br></pre></td></tr></table></figure>

<p>有了这个函数，我们继续实现删除函数中的第四种情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># case 4: two children</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    successor = self.__get_successor(current)</span><br><span class="line">    <span class="keyword">if</span> current == self.root:</span><br><span class="line">        self.root = successor</span><br><span class="line">    <span class="keyword">elif</span> is_left_child:</span><br><span class="line">        parent.left = successor</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent.right = successor</span><br><span class="line">    successor.left = current.left</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>对于树的遍历一般有三种：</p>
<ul>
<li>Inorder：遍历顺序为 left -&gt; parent -&gt; right</li>
<li>Preorder：顺序为 parent -&gt; left -&gt; right</li>
<li>Postorder：顺序为 left -&gt; right -&gt; parent</li>
</ul>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>遍历二叉树最常用的就是深度优先搜索和广度优先搜索，Inorder DFS 遍历可以通过递归简单地实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_traverse</span>(<span class="params">self</span>) -&gt; [int]:</span></span><br><span class="line">    self.ret = []</span><br><span class="line">    self.__in_order(self.root)</span><br><span class="line">    <span class="keyword">return</span> self.ret</span><br><span class="line"><span class="comment"># helper method</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__in_order</span>(<span class="params">self, node: self.Node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.__in_order(node.left)</span><br><span class="line">    self.ret.append(node.key)</span><br><span class="line">    self.__in_order(node.right)</span><br></pre></td></tr></table></figure>

<p>Preorder 和 Postorder 仅需要交换最后三行代码的顺序即可，不做赘述。</p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>广度优先搜索的中心思想就是从根节点开始沿着树的宽度遍历树的节点，一般会用一个 Queue 来保持所有展开的节点。一个简单的实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_traverse</span>(<span class="params">self</span>) -&gt; [int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    queue = [self.root]</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">        ret.append(node.key)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h3 id="Iterative"><a href="#Iterative" class="headerlink" title="Iterative"></a>Iterative</h3><p>Iterative 的遍历就比较有意思了，通常是利用一个栈来模拟 DFS 递归调用的过程。</p>
<h4 id="Inorder"><a href="#Inorder" class="headerlink" title="Inorder"></a>Inorder</h4><p>保持一个 Stack，循环：</p>
<ul>
<li>寻找树的最左边节点，一路上所有的元素都入栈</li>
<li>出栈，访问节点</li>
<li>如果这个节点存在右子树，回到第一步（即寻找右子树的最左边节点，一路上所有元素都入栈）</li>
</ul>
<p>直到栈变成空，表示我们已经访问过了所有的元素。</p>
<p>Inorder iterative 的实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder_traverse</span>(<span class="params">self</span>) -&gt; [int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = []</span><br><span class="line">    ret = []</span><br><span class="line">    current = self.root</span><br><span class="line">    <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="comment"># add all through the left-most node of the tree</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            stack.append(current)</span><br><span class="line">            current = current.left</span><br><span class="line">        current = stack.pop()</span><br><span class="line">        ret.append(current.key)</span><br><span class="line">        <span class="comment"># if the removed node still has non-empty right subtree,</span></span><br><span class="line">        <span class="comment"># add all through the right node&#x27;s left most child</span></span><br><span class="line">        current = current.right</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h4 id="Preorder"><a href="#Preorder" class="headerlink" title="Preorder"></a>Preorder</h4><p>保持一个 Stack，初始化为 <code>[root]</code>，循环：</p>
<ul>
<li>出栈，访问节点</li>
<li>如果有右子树，入栈</li>
<li>如果有左子树，入栈</li>
</ul>
<p>注意：由于栈后入先出的特性，这里入栈的顺序（先右再左）和访问的顺序（先左再右）相反。</p>
<p>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_traverse</span>(<span class="params">self</span>) -&gt; [int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = [self.root]</span><br><span class="line">    ret = []</span><br><span class="line">    current = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        current = stack.pop()</span><br><span class="line">        ret.append(current.key)</span><br><span class="line">        <span class="keyword">if</span> current.right:</span><br><span class="line">            stack.append(current.right)</span><br><span class="line">        <span class="keyword">if</span> current.left:</span><br><span class="line">            stack.append(current.left)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h4 id="Postorder"><a href="#Postorder" class="headerlink" title="Postorder"></a>Postorder</h4><p>后序遍历可以仿照前序遍历的写法，不同的是我们可以构造一个按 parent -&gt; right -&gt; left 访问的顺序，然后把遍历结果反转过来即可得到后序遍历结果。</p>
<p>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder_traversal</span>(<span class="params">self</span>) -&gt; [int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack = [self.root]</span><br><span class="line">    ret = []</span><br><span class="line">    current = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        current = stack.pop()</span><br><span class="line">        ret.append(current.key)</span><br><span class="line">        <span class="keyword">if</span> current.left:</span><br><span class="line">            stack.append(current.left)</span><br><span class="line">        <span class="keyword">if</span> current.right:</span><br><span class="line">            stack.append(current.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reversed</span>(ret)</span><br></pre></td></tr></table></figure>

<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><p>堆是一类基于树的特殊的数据结构，通常我们反复从堆中提取一个最大值或最小值，这里我们以最大堆 Max Heap 为例。最大堆是一个二叉树，且具有以下性质：</p>
<ul>
<li>（几乎是）完全二叉树：除最底层外，每一层的树都从左到右完全具有节点</li>
<li>最大值在树的根节点</li>
<li>最大堆的每个节点的子树都小于它</li>
</ul>
<p>堆不是一个排好序的数据结构，而是可以被看作部分有序。堆的高度为 log(n)。一个最大堆的主要操作是 <code>insert()</code> 和 <code>removeMax()</code>（最小堆就是 <code>removeMin()</code>），后面会详解。</p>
<h2 id="基于数组的实现"><a href="#基于数组的实现" class="headerlink" title="基于数组的实现"></a>基于数组的实现</h2><p>由于堆是（几乎）完全二叉树的性质，我们可以利用一个数组实现堆。对一个（几乎）完全二叉树，可以对每个元素从左到右、从上到下从 1 开始编号：</p>
<p><img src="/images/171219/3.png"></p>
<p>可以发现规律：每个节点的左子节点编号是它的编号的二倍，右子节点的编号是它编号二倍加一。利用这个规律，我们可以推出数组下标（从 0 开始）的关系：</p>
<ul>
<li>parent = (index - 1) / 2</li>
<li>leftChild = index * 2 + 1</li>
<li>rightChild = (index + 1) * 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.heap_array = []</span><br><span class="line">    <span class="comment"># Node</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">            self.key = key</span><br></pre></td></tr></table></figure>

<h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>向最大堆插入元素的算法如下：</p>
<ul>
<li>把新的数据插入到堆的下一个节点，使堆保持（几乎）完全二叉树结构。一般来说如果最后一层不满就往右边插入，最后一层满了就插到下一行的最左边</li>
<li>比较新节点和父节点，如果新节点较大，则把新的节点和它的父节点交换。重复这个过程，直到整个树满足堆的条件</li>
</ul>
<p><img src="/images/171219/4.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># insert into MaxHeap</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, key</span>):</span></span><br><span class="line">    new_node = self.Node(key)</span><br><span class="line">    self.heap_array.append(new_node)</span><br><span class="line">    self.__percolate_up(<span class="built_in">len</span>(self.heap_array) - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># percolate up helper function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__percolate_up</span>(<span class="params">self, index: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="comment"># save the bottom node</span></span><br><span class="line">    bottom = self.heap_array[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># find the initial index value of parent</span></span><br><span class="line">    parent = <span class="built_in">int</span>((index - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># while parent&#x27;s key is smaller than the new key</span></span><br><span class="line">    <span class="keyword">while</span> index &gt; <span class="number">0</span> <span class="keyword">and</span> self.heap_array[parent].key &lt; bottom.key:</span><br><span class="line">        <span class="comment"># parent node comes down</span></span><br><span class="line">        self.heap_array[index] = self.heap_array[parent]</span><br><span class="line">        index = parent <span class="comment"># index moves up</span></span><br><span class="line">        parent = <span class="built_in">int</span>((parent - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># finally, insert newly added node into proper position</span></span><br><span class="line">    self.heap_array[index] = bottom</span><br></pre></td></tr></table></figure>

<h2 id="RemoveMax"><a href="#RemoveMax" class="headerlink" title="RemoveMax"></a>RemoveMax</h2><p>从最大堆移除最大元素的算法如下：</p>
<ul>
<li>移除掉根节点（就是最大的元素）并把整个树最底层的节点替换到根的位置，以使堆保持完全二叉树结构</li>
<li>如果这个节点比它的较大的子节点小，则交换它们；重复这个过程直到整个树满足堆的条件</li>
</ul>
<p><img src="/images/171219/5.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_max</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.heap_array:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    root = self.heap_array[<span class="number">0</span>]</span><br><span class="line">    self.heap_array[<span class="number">0</span>] = self.heap_array[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">del</span> self.heap_array[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> self.heap_array:</span><br><span class="line">        self.__perculate_down(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> root.key</span><br><span class="line"><span class="comment"># perculate down helper function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__perculate_down</span>(<span class="params">self, index</span>):</span></span><br><span class="line">    top = self.heap_array[index]</span><br><span class="line">    larger_child = <span class="number">-1</span> <span class="comment"># larger child&#x27;s index</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="built_in">int</span>(<span class="built_in">len</span>(self.heap_array) / <span class="number">2</span>):</span><br><span class="line">        left_child = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        right_child = (index + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        <span class="comment"># find which one is larger</span></span><br><span class="line">        <span class="keyword">if</span> right_child &lt; <span class="built_in">len</span>(self.heap_array) <span class="keyword">and</span> self.heap_array[left_child].key &lt; self.heap_array[right_child].key:</span><br><span class="line">            larger_child = right_child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            larger_child = left_child</span><br><span class="line">        <span class="comment"># no need to go down any more</span></span><br><span class="line">        <span class="keyword">if</span> self.heap_array[larger_child].key &lt;= top.key:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># move the nodes up</span></span><br><span class="line">        self.heap_array[index] = self.heap_array[larger_child]</span><br><span class="line">        <span class="comment"># index goes down toward larger child</span></span><br><span class="line">        index = larger_child</span><br><span class="line">    <span class="comment"># put top key into proper location to restore the heap</span></span><br><span class="line">    self.heap_array[index] = top</span><br></pre></td></tr></table></figure>

<h2 id="堆排序和优先队列"><a href="#堆排序和优先队列" class="headerlink" title="堆排序和优先队列"></a>堆排序和优先队列</h2><p>堆排序是一种非常有趣的排序方法，基本思路就是从未排序的数组一个个把元素丢到堆里，然后再一遍遍 <code>removeMax()</code> 或 <code>removeMin()</code>，就得到了排好序的数组。插入和移除操作的 worst-case 都是 O(n log n)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">unsorted: [<span class="built_in">int</span>]</span>) -&gt; [int]:</span></span><br><span class="line">    h = MinHeap()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> unsorted:</span><br><span class="line">        h.insert(i)</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(unsorted)):</span><br><span class="line">        ret.append(h.remove_min())</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>在 Java <code>Collections</code> 框架的实现中，<code>PriorityQueue</code> 类就是使用最小堆实现的。因此，遍历一个优先队列不能保证元素的顺序（因为堆是部分有序的），必须要一个个出队才能获得正确的顺序。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上就是几种基础的数据结构和它们的简单实现。不同数据结构由于设计和实现的不同，在看似相同的方法背后有着截然不同的原理和复杂度。在日常开发过程中，一定要根据业务需求选择合适的数据结构，合理利用系统资源，提高总体运行效率。</p>

    </section>
    <footer class="post-footer">
      <section class="author">
    <h4>Yubo Qin</h4>
    <p>真不错</p>
</section>
      <section class="share">
  <h4>分享这篇文章</h4>
  <a target="_blank" rel="noopener" href='https://www.linkedin.com/sharing/share-offsite/?url=https://xnth97.github.io/2017/12/20/data-structure-note/' onclick="window.open(this.href, 'linkedin-share', 'width=720,height=480');return false;">
    <svg class='icon'>
      <use xlink:href='#icon-linkedin'></use>
    </svg>
    <span class='hidden'>LinkedIn</span>
  </a>
  <a target="_blank" rel="noopener" href='http://service.weibo.com/share/share.php?appkey=&title=数据结构笔记&url=https://xnth97.github.io/2017/12/20/data-structure-note/&pic=&searchPic=false&style=simple' onclick="window.open(this.href, 'weibo-share', 'width=640,height=360');return false;">
    <svg class='icon'>
      <use xlink:href='#icon-sina-weibo'></use>
    </svg>
    <span class='hidden'>Sina Weibo</span>
  </a>
  <a target="_blank" rel="noopener" href='http://twitter.com/share?url=https://xnth97.github.io/2017/12/20/data-structure-note/'
    onclick="window.open(this.href, 'twitter-share', 'width=640,height=480');return false;">
    <svg class="icon">
      <use xlink:href="#icon-twitter"></use>
    </svg>
    <span class="hidden">Twitter</span>
  </a>
  <a target="_blank" rel="noopener" href='https://www.facebook.com/sharer/sharer.php?u=https://xnth97.github.io/2017/12/20/data-structure-note/'
    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
    <svg class="icon">
      <use xlink:href="#icon-facebook2"></use>
    </svg>
    <span class="hidden">Facebook</span>
  </a>
</section>
    </footer>
  </article>
  <nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2018/02/05/sorting-algorithms/">
        ← 排序算法笔记
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2017/10/26/raspberry-pi/">
        Raspberry Pi 手记 →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <div id="disqus_thread"></div>
    <script>
    // var disqus_config = function () {
    // this.page.url = page.permalink;  // Replace PAGE_URL with your page's canonical URL variable
    // this.page.identifier = page.title; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    // };
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://xnth97.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">2022 &copy; Yubo Qin &bull; <a href="/about">关于我</a></section>
  </div>
</footer>

  <script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script>
  function addDarkmodeWidget() {
    const options = {
      label: '🌓',
      autoMatchOsTheme: true
    };

    const darkmode = new Darkmode(options);
    darkmode.showWidget();
  }
  window.addEventListener('load', addDarkmodeWidget);
</script>
</body>
</html>
