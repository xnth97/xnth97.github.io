<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <title>用 Golang 撸一个玩具编译器 | NOWHERE</title>
  <meta name="author" content="Yubo Qin" />
  <meta name="description" content="一些碎碎念" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/images/blog/favicon/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/blog/favicon/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/blog/favicon/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/blog/favicon/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon-precomposed" sizes="60x60" href="/images/blog/favicon/apple-touch-icon-60x60.png" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/images/blog/favicon/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/images/blog/favicon/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/images/blog/favicon/apple-touch-icon-152x152.png" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-196x196.png" sizes="196x196" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-16x16.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="/images/blog/favicon/favicon-128.png" sizes="128x128" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200;300;400;500;600;700;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">

  <meta name="generator" content="NOWHERE">

  
  
  
</head>


<body class="post-template">

  <!-- Generated using IconMoon -->
<svg aria-hidden="true" style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <defs>
  <symbol id="icon-facebook2" viewBox="0 0 32 32">
  <path d="M29 0h-26c-1.65 0-3 1.35-3 3v26c0 1.65 1.35 3 3 3h13v-14h-4v-4h4v-2c0-3.306 2.694-6 6-6h4v4h-4c-1.1 0-2 0.9-2 2v2h6l-1 4h-5v14h9c1.65 0 3-1.35 3-3v-26c0-1.65-1.35-3-3-3z"></path>
  </symbol>
  <symbol id="icon-twitter" viewBox="0 0 32 32">
  <path d="M32 7.075c-1.175 0.525-2.444 0.875-3.769 1.031 1.356-0.813 2.394-2.1 2.887-3.631-1.269 0.75-2.675 1.3-4.169 1.594-1.2-1.275-2.906-2.069-4.794-2.069-3.625 0-6.563 2.938-6.563 6.563 0 0.512 0.056 1.012 0.169 1.494-5.456-0.275-10.294-2.888-13.531-6.862-0.563 0.969-0.887 2.1-0.887 3.3 0 2.275 1.156 4.287 2.919 5.463-1.075-0.031-2.087-0.331-2.975-0.819 0 0.025 0 0.056 0 0.081 0 3.181 2.263 5.838 5.269 6.437-0.55 0.15-1.131 0.231-1.731 0.231-0.425 0-0.831-0.044-1.237-0.119 0.838 2.606 3.263 4.506 6.131 4.563-2.25 1.762-5.075 2.813-8.156 2.813-0.531 0-1.050-0.031-1.569-0.094 2.913 1.869 6.362 2.95 10.069 2.95 12.075 0 18.681-10.006 18.681-18.681 0-0.287-0.006-0.569-0.019-0.85 1.281-0.919 2.394-2.075 3.275-3.394z"></path>
  </symbol>
  <symbol id="icon-sina-weibo" viewBox="0 0 32 32">
  <path d="M13.444 28.063c-5.3 0.525-9.875-1.875-10.219-5.35-0.344-3.481 3.675-6.719 8.969-7.244 5.3-0.525 9.875 1.875 10.213 5.35 0.35 3.481-3.669 6.725-8.963 7.244zM24.038 16.519c-0.45-0.137-0.762-0.225-0.525-0.819 0.512-1.287 0.563-2.394 0.006-3.188-1.038-1.481-3.881-1.406-7.137-0.037 0 0-1.025 0.444-0.762-0.363 0.5-1.613 0.425-2.956-0.356-3.738-1.769-1.769-6.469 0.069-10.5 4.1-3.013 3.006-4.763 6.213-4.763 8.981 0 5.288 6.787 8.506 13.425 8.506 8.7 0 14.494-5.056 14.494-9.069 0-2.431-2.044-3.806-3.881-4.375z"></path>
  <path d="M29.819 6.831c-2.1-2.331-5.2-3.219-8.063-2.612v0c-0.663 0.144-1.081 0.794-0.938 1.45 0.144 0.662 0.788 1.081 1.45 0.938 2.038-0.431 4.238 0.2 5.731 1.856s1.9 3.912 1.256 5.888v0c-0.206 0.644 0.144 1.331 0.788 1.544 0.644 0.206 1.331-0.144 1.544-0.787v-0.006c0.9-2.762 0.331-5.938-1.769-8.269z"></path>
  <path d="M26.587 9.75c-1.025-1.137-2.538-1.569-3.925-1.269-0.569 0.119-0.931 0.688-0.813 1.256 0.125 0.569 0.688 0.931 1.25 0.806v0c0.681-0.144 1.419 0.069 1.919 0.619 0.5 0.556 0.637 1.313 0.419 1.975v0c-0.175 0.55 0.125 1.15 0.681 1.331 0.556 0.175 1.15-0.125 1.331-0.681 0.438-1.356 0.163-2.906-0.863-4.037z"></path>
  <path d="M13.738 21.769c-0.188 0.319-0.594 0.469-0.912 0.337-0.319-0.125-0.412-0.488-0.231-0.794 0.188-0.306 0.581-0.456 0.894-0.337 0.313 0.113 0.425 0.469 0.25 0.794zM12.044 23.931c-0.512 0.819-1.613 1.175-2.438 0.8-0.813-0.369-1.056-1.319-0.544-2.119 0.506-0.794 1.569-1.15 2.387-0.806 0.831 0.356 1.1 1.3 0.594 2.125zM13.969 18.144c-2.519-0.656-5.369 0.6-6.463 2.819-1.119 2.262-0.037 4.781 2.506 5.606 2.637 0.85 5.75-0.456 6.831-2.894 1.069-2.394-0.262-4.85-2.875-5.531z"></path>
  </symbol>
  <symbol id="icon-linkedin" viewBox="0 0 32 32">
  <path d="M29 0h-26c-1.65 0-3 1.35-3 3v26c0 1.65 1.35 3 3 3h26c1.65 0 3-1.35 3-3v-26c0-1.65-1.35-3-3-3zM12 26h-4v-14h4v14zM10 10c-1.106 0-2-0.894-2-2s0.894-2 2-2c1.106 0 2 0.894 2 2s-0.894 2-2 2zM26 26h-4v-8c0-1.106-0.894-2-2-2s-2 0.894-2 2v8h-4v-14h4v2.481c0.825-1.131 2.087-2.481 3.5-2.481 2.488 0 4.5 2.238 4.5 5v9z"></path>
  </symbol>
  </defs>
  </svg>

  <header class="site-head"  style="background-image: url(/images/blog/cover.jpg)" >
  <div class="vertical">
    <div class="site-head-content inner">
       
      <a 
        class="blog-logo"
        href="/">
        <img src="/images/blog/avatar.png" alt="Blog Logo" />
      </a> 
      
      <h1 class="blog-title">NOWHERE</h1>
      <h2 class="blog-description">一些碎碎念</h2>
    </div>

    
  </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
  <time datetime="2020-05-29T13:40:06.000Z" itemprop="datePublished">
    2020-05-29
  </time>
  
    
    
      <a href='/tags/coding/'>coding</a>,
    
      <a href='/tags/note/'>note</a>
    
  
</span>
    <h1 class="post-title">用 Golang 撸一个玩具编译器</h1>
    <section class="post-content">
      <p>社畜以来每日搬砖，很久没有像读书时一样学习一些东西沉淀下了。最近在 GitHub 上看到 <a target="_blank" rel="noopener" href="https://github.com/jamiebuilds/the-super-tiny-compiler">the-super-tiny-compiler</a> 这个项目，很喜欢它极简的设计和实现，也给了对编译原理一知半解的我一个从头再来的机会。个人感觉原项目用 JavaScript 抹去了一些实现细节的同时也模糊了具体的理解，故此用 Golang 学习与实现。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里我们实现的玩具编译器是将 lisp 风格的代码转化为 C 语法，例如 <code>(add 2 (subtract 4 2))</code> 会被转化成 <code>add(2, subtract(4, 2));</code>。大部分现代编译器工作主要有三个过程：</p>
<ul>
<li>Parsing：将源代码解析为抽象表达（如抽象语法树 Abstract syntax tree）</li>
<li>Transformation：操作 AST 并做一些编译器需要的工作</li>
<li>Code Generation：将变形后的代码生成新的代码</li>
</ul>
<p>按照我 iOS 的经验，这大概对应的是：</p>
<ul>
<li>Clang 对 C&#x2F;C++&#x2F;Objective-C&#x2F;Swift 代码进行词法分析、静态分析等，生成 AST <code>clang -Xclang -ast-dump</code></li>
<li>Clang 将 AST 生成 LLVM 中间代码并进行编译优化，例如全局变量、循环、尾递归等情况 <code>clang -emit-llvm</code></li>
<li>Clang 将优化后的 LLVM 代码生成汇编代码 <code>clang -S -o</code>，assembler 将汇编代码生成机器码，linker 将机器码和静态库链接生成 Mach-O 可执行文件</li>
</ul>
<h2 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h2><p>解析主要是词法分析（lexical analysis）和句法分析（syntactic analysis）。</p>
<h3 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h3><p>词法分析中 tokenizer 将原始代码拆分成 token（或 lexer）。比如 <code>(add 2 4)</code> 会被解析为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;paren&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;name&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;number&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;number&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;paren&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这里我们定义 token 包括两个属性：type 和 value。首先声明我们需要的 token type 和结构体：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TokenType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    TokenTypeParen  TokenType = <span class="string">&quot;paren&quot;</span></span><br><span class="line">    TokenTypeName   TokenType = <span class="string">&quot;name&quot;</span></span><br><span class="line">    TokenTypeNumber TokenType = <span class="string">&quot;number&quot;</span></span><br><span class="line">    TokenTypeString TokenType = <span class="string">&quot;string&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Token <span class="keyword">struct</span> &#123;</span><br><span class="line">    tokenType TokenType</span><br><span class="line">    value     <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tokenizer 函数接受 input 字符串，遍历并根据当前字符生成 token，最后返回 token 数组。这里我们利用了 Golang 的 <code>unicode</code> 包实现快速的判断。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tokenizer</span><span class="params">(input <span class="type">string</span>)</span></span> []Token &#123;</span><br><span class="line">    <span class="comment">// counter</span></span><br><span class="line">    current := <span class="number">0</span></span><br><span class="line">    <span class="comment">// token array to be returned</span></span><br><span class="line">    tokens := <span class="built_in">make</span>([]Token, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// iterate</span></span><br><span class="line">    <span class="keyword">for</span> current &lt; <span class="built_in">len</span>(input) &#123;</span><br><span class="line">        char := input[current]</span><br><span class="line">        charStr := <span class="type">string</span>(char)</span><br><span class="line">        <span class="keyword">if</span> charStr == <span class="string">&quot;(&quot;</span> || charStr == <span class="string">&quot;)&quot;</span> &#123;</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, Token&#123;TokenTypeParen, charStr&#125;)</span><br><span class="line">            current++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        charRune := <span class="type">rune</span>(char)</span><br><span class="line">        <span class="keyword">if</span> unicode.IsSpace(charRune) &#123;</span><br><span class="line">            current++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> unicode.IsDigit(charRune) &#123;</span><br><span class="line">            value := <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> unicode.IsDigit(<span class="type">rune</span>(char)) &#123;</span><br><span class="line">                value = value + <span class="type">string</span>(char)</span><br><span class="line">                current++</span><br><span class="line">                char = input[current]</span><br><span class="line">            &#125;</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, Token&#123;TokenTypeNumber, value&#125;)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> charStr == <span class="string">&quot;\&quot;&quot;</span> &#123;</span><br><span class="line">            value := <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="comment">// skip opening parenthesis</span></span><br><span class="line">            current++</span><br><span class="line">            char = input[current]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// for characters that are not &quot;\&quot;&quot;, append to value of current token</span></span><br><span class="line">            <span class="keyword">for</span> <span class="type">string</span>(char) != <span class="string">&quot;\&quot;&quot;</span> &#123;</span><br><span class="line">                value = value + <span class="type">string</span>(char)</span><br><span class="line">                current++</span><br><span class="line">                char = input[current]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// skip closing parenthesis</span></span><br><span class="line">            current++</span><br><span class="line">            char = input[current]</span><br><span class="line"></span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, Token&#123;TokenTypeString, value&#125;)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> unicode.IsLetter(charRune) &#123;</span><br><span class="line">            value := <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> unicode.IsLetter(<span class="type">rune</span>(char)) &#123;</span><br><span class="line">                value = value + <span class="type">string</span>(char)</span><br><span class="line">                current++</span><br><span class="line">                char = input[current]</span><br><span class="line">            &#125;</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, Token&#123;TokenTypeName, value&#125;)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Syntactic-Analysis"><a href="#Syntactic-Analysis" class="headerlink" title="Syntactic Analysis"></a>Syntactic Analysis</h3><p>句法分析将 token 数组解析为抽象语法树。顾名思义，AST 是树状结构，例如上文的 <code>(add 2 4)</code> 解析而来的 token 数组会被进一步解析为 AST 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Program&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: [&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;CallExpression&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">        <span class="attr">params</span>: [&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;NumberLiteral&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;NumberLiteral&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">        &#125;],</span><br><span class="line">    &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AST 的每个节点可定义如下，注意 <code>params</code> 我们定义为一个指针数组，数组中每个元素都是指向 <code>ASTNode</code> 的指针。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ASTNodeType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    ASTNodeTypeProgram             ASTNodeType = <span class="string">&quot;Program&quot;</span></span><br><span class="line">    ASTNodeTypeNumberLiteral       ASTNodeType = <span class="string">&quot;NumberLiteral&quot;</span></span><br><span class="line">    ASTNodeTypeStringLiteral       ASTNodeType = <span class="string">&quot;StringLiteral&quot;</span></span><br><span class="line">    ASTNodeTypeCallExpression      ASTNodeType = <span class="string">&quot;CallExpression&quot;</span></span><br><span class="line">    ASTNodeTypeExpressionStatement ASTNodeType = <span class="string">&quot;ExpressionStatement&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ASTNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodeType   ASTNodeType</span><br><span class="line">    value      <span class="type">string</span></span><br><span class="line">    params     []*ASTNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parser 函数接受 token 数组并返回 AST 根结点。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parser</span><span class="params">(tokens []Token)</span></span> ASTNode &#123;</span><br><span class="line">    current := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursively walk through nodes</span></span><br><span class="line">    <span class="keyword">var</span> walk <span class="function"><span class="keyword">func</span><span class="params">()</span></span> ASTNode</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create root node</span></span><br><span class="line">    ast := ASTNode&#123;</span><br><span class="line">        nodeType: ASTNodeTypeProgram,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push nodes to ast.params</span></span><br><span class="line">    <span class="keyword">for</span> current &lt; <span class="built_in">len</span>(tokens) &#123;</span><br><span class="line">        tmp := walk()</span><br><span class="line">        ast.params = <span class="built_in">append</span>(ast.params, &amp;tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ast</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间我们使用一个闭包 <code>walk()</code> 来根据 <code>current</code> 把 Token 解析为 ASTNode。预先声明闭包的原因是 Golang 不允许通过海象运算符（:&#x3D;）声明的闭包调用自己。<code>walk</code> 闭包实现如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">walk = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> ASTNode &#123;</span><br><span class="line">    token := tokens[current]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> token.tokenType == TokenTypeNumber &#123;</span><br><span class="line">        current++</span><br><span class="line">        <span class="keyword">return</span> ASTNode&#123;</span><br><span class="line">            nodeType: ASTNodeTypeNumberLiteral,</span><br><span class="line">            value:    token.value,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> token.tokenType == TokenTypeString &#123;</span><br><span class="line">        current++</span><br><span class="line">        <span class="keyword">return</span> ASTNode&#123;</span><br><span class="line">            nodeType: ASTNodeTypeStringLiteral,</span><br><span class="line">            value:    token.value,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> token.tokenType == TokenTypeParen &amp;&amp; token.value == <span class="string">&quot;(&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// skip opening parenthesis</span></span><br><span class="line">        current++</span><br><span class="line">        token = tokens[current]</span><br><span class="line"></span><br><span class="line">        node := ASTNode&#123;</span><br><span class="line">            nodeType: ASTNodeTypeCallExpression,</span><br><span class="line">            value:    token.value,</span><br><span class="line">            params:   []*ASTNode&#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// skip name token</span></span><br><span class="line">        current++</span><br><span class="line">        token = tokens[current]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> token.tokenType != TokenTypeParen || (token.tokenType == TokenTypeParen &amp;&amp; token.value != <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">            tmp := walk()</span><br><span class="line">            node.params = <span class="built_in">append</span>(node.params, &amp;tmp)</span><br><span class="line">            token = tokens[current]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip closing parenthesis</span></span><br><span class="line">        current++</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should not get here</span></span><br><span class="line">    <span class="keyword">return</span> ASTNode&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><p>真实的编译器可能会进行很多优化并生成中间代码，但在玩具编译器里我们只是操作 AST，进行一些改动并生成新的 AST。一般来说也可以直接更改原始 AST，但鉴于我们是 target 另一种语言（lisp -&gt; C）我们还是创建一棵新的 AST。</p>
<h3 id="Traverser"><a href="#Traverser" class="headerlink" title="Traverser"></a>Traverser</h3><p>为了操作 AST，我们需要 traverser 去深度优先遍历 AST，并对每个类型的节点执行不同的操作。这里我们使用一个 map，key 是节点的类型，value 是我们需要执行的操作。对于每个节点，我们需要在开始遍历节点时（enter）以及结束遍历其子树时（exit）执行，因此我们声明一个 <code>Methods</code> 结构体，具有 <code>enter</code> 和 <code>exit</code> 两个闭包属性，每个闭包接受 <code>node</code> 和 <code>parent</code> 两个参数表示当前节点和父节点。由于闭包需要对节点进行改动，类型为指向节点的指针。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Methods <span class="keyword">struct</span> &#123;</span><br><span class="line">    enter <span class="function"><span class="keyword">func</span><span class="params">(*ASTNode, *ASTNode)</span></span></span><br><span class="line">    exit  <span class="function"><span class="keyword">func</span><span class="params">(*ASTNode, *ASTNode)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此我们的 map 类型为 <code>map[ASTNodeType]Methods</code>，可以实现 traverser 如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Traverser</span><span class="params">(ast *ASTNode, visitor <span class="keyword">map</span>[ASTNodeType]Methods)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> traverseNode <span class="function"><span class="keyword">func</span><span class="params">(*ASTNode, *ASTNode)</span></span></span><br><span class="line">    <span class="keyword">var</span> traverseArray <span class="function"><span class="keyword">func</span><span class="params">([]*ASTNode, *ASTNode)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// helper that iterate over an array</span></span><br><span class="line">    traverseArray = <span class="function"><span class="keyword">func</span><span class="params">(array []*ASTNode, parent *ASTNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(array); i++ &#123;</span><br><span class="line">            traverseNode(array[i], parent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traverseNode = <span class="function"><span class="keyword">func</span><span class="params">(node *ASTNode, parent *ASTNode)</span></span> &#123;</span><br><span class="line">        methods := visitor[node.nodeType]</span><br><span class="line">        <span class="comment">// call enter</span></span><br><span class="line">        <span class="keyword">if</span> methods.enter != <span class="literal">nil</span> &#123;</span><br><span class="line">            methods.enter(node, parent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// traverse by current node type</span></span><br><span class="line">        <span class="keyword">switch</span> node.nodeType &#123;</span><br><span class="line">        <span class="keyword">case</span> ASTNodeTypeProgram, ASTNodeTypeCallExpression:</span><br><span class="line">            traverseArray(node.params, node)</span><br><span class="line">        <span class="keyword">case</span> ASTNodeTypeNumberLiteral, ASTNodeTypeStringLiteral, ASTNodeTypeExpressionStatement:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// call exit</span></span><br><span class="line">        <span class="keyword">if</span> methods.exit != <span class="literal">nil</span> &#123;</span><br><span class="line">            methods.exit(node, parent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traverseNode(ast, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>Transformer 需要调用 <code>Traverser()</code> 函数将 AST 生成新的 AST，转化的例子在 <a target="_blank" rel="noopener" href="https://github.com/jamiebuilds/the-super-tiny-compiler/blob/d8d40130459d1537f6117a927947cd46c83182b0/the-super-tiny-compiler.js#L821">这里</a> 可以看到。对于新的 AST，我们需要添加一些属性来扩充 <code>ASTNode</code> 的定义。比较重要的是 <code>context *[]*ASTNode</code>，我们用它来表示一个<strong>从</strong>旧 AST 到新 AST <code>params</code> 的引用，因此它的类型需要为指针数组的指针，这样当我们修改旧 AST 节点的 <code>context</code> 时，对应的变更也会反映在新 AST 的 <code>params</code> 上。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Callee <span class="keyword">struct</span> &#123;</span><br><span class="line">    calleeType <span class="type">string</span></span><br><span class="line">    name       <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ASTNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodeType   ASTNodeType</span><br><span class="line">    value      <span class="type">string</span></span><br><span class="line">    callee     Callee</span><br><span class="line">    expression *ASTNode</span><br><span class="line">    params     []*ASTNode</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reference from old ast to new ast</span></span><br><span class="line">    context    *[]*ASTNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transformer 函数如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transformer</span><span class="params">(ast *ASTNode)</span></span> ASTNode &#123;</span><br><span class="line">    newAst := ASTNode&#123;</span><br><span class="line">        nodeType: ASTNodeTypeProgram,</span><br><span class="line">        params:   []*ASTNode&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// so we can push nodes to parent&#x27;s context</span></span><br><span class="line">    ast.context = &amp;newAst.params</span><br><span class="line"></span><br><span class="line">    Traverser(ast, <span class="keyword">map</span>[ASTNodeType]Methods&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newAst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来针对不同类型添加 <code>enter</code> 方法。对于 literal 节点，我们简单地创建新 <code>ASTNode</code> 并添加到父节点的 <code>context</code> 即可。由于 <code>context</code> 是指向新 AST <code>params</code> 的引用，新 <code>ASTNode</code> 也会被添加到新 AST 对应的 <code>params</code> 中。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[ASTNodeType]Methods&#123;</span><br><span class="line">    ASTNodeTypeNumberLiteral: Methods&#123;</span><br><span class="line">        enter: <span class="function"><span class="keyword">func</span><span class="params">(node *ASTNode, parent *ASTNode)</span></span> &#123;</span><br><span class="line">            tmp := ASTNode&#123;</span><br><span class="line">                nodeType: ASTNodeTypeNumberLiteral,</span><br><span class="line">                value:    node.value,</span><br><span class="line">            &#125;</span><br><span class="line">            *parent.context = <span class="built_in">append</span>(*parent.context, &amp;tmp)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ASTNodeTypeStringLiteral: Methods&#123;</span><br><span class="line">        enter: <span class="function"><span class="keyword">func</span><span class="params">(node *ASTNode, parent *ASTNode)</span></span> &#123;</span><br><span class="line">            tmp := ASTNode&#123;</span><br><span class="line">                nodeType: ASTNodeTypeStringLiteral,</span><br><span class="line">                value:    node.value,</span><br><span class="line">            &#125;</span><br><span class="line">            *parent.context = <span class="built_in">append</span>(*parent.context, &amp;tmp)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里将节点添加到 <code>context</code> 的操作，由于 <code>context</code> 是数组指针，我们需要对它指向的内容进行操作，因此有额外的取值符。而数组元素是指向节点的指针，因此需要对生成的节点取地址。许久以来 Swift 写得一把梭已经差不多忘记这个级别的操作了。</p>
<p>最后对 CallExpression 类型，由于表达式具有参数，我们需要把旧节点的 <code>context</code> 指向新节点的 <code>params</code>，就如同我们对根结点做的一样。另外在这个玩具解释器中，如果父节点不是 CallExpression 类型，我们需要创建一个 ExpressionStatement 去嵌套一下。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ASTNodeTypeCallExpression: Methods&#123;</span><br><span class="line">    enter: <span class="function"><span class="keyword">func</span><span class="params">(node *ASTNode, parent *ASTNode)</span></span> &#123;</span><br><span class="line">        expression := ASTNode&#123;</span><br><span class="line">            nodeType: ASTNodeTypeCallExpression,</span><br><span class="line">            callee:   Callee&#123;<span class="string">&quot;Identifier&quot;</span>, node.value&#125;,</span><br><span class="line">            params:   []*ASTNode&#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// context of CallExpression refer to express&#x27;s params so</span></span><br><span class="line">        <span class="comment">// that we can push parameters</span></span><br><span class="line">        node.context = &amp;expression.params</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> parent.nodeType != ASTNodeTypeCallExpression &#123;</span><br><span class="line">            <span class="comment">// if not CallExpression, we need to wrap</span></span><br><span class="line">            newExpression := ASTNode&#123;</span><br><span class="line">                nodeType:   ASTNodeTypeExpressionStatement,</span><br><span class="line">                expression: &amp;expression,</span><br><span class="line">            &#125;</span><br><span class="line">            *parent.context = <span class="built_in">append</span>(*parent.context, &amp;newExpression)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *parent.context = <span class="built_in">append</span>(*parent.context, &amp;expression)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="Code-Generation"><a href="#Code-Generation" class="headerlink" title="Code Generation"></a>Code Generation</h2><p>最后就是将新 AST 解析成 C 风格代码了。Code generator 的实现非常直接，针对不同节点类型生成不同代码，并对子节点递归调用自身就可以了。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CodeGenerator</span><span class="params">(node ASTNode)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> node.nodeType &#123;</span><br><span class="line">    <span class="keyword">case</span> ASTNodeTypeProgram:</span><br><span class="line">        res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, param := <span class="keyword">range</span> node.params &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, CodeGenerator(*param))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strings.Join(res, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ASTNodeTypeExpressionStatement:</span><br><span class="line">        <span class="keyword">return</span> CodeGenerator(*node.expression) + <span class="string">&quot;;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ASTNodeTypeCallExpression:</span><br><span class="line">        params := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, param := <span class="keyword">range</span> node.params &#123;</span><br><span class="line">            params = <span class="built_in">append</span>(params, CodeGenerator(*param))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.callee.name + <span class="string">&quot;(&quot;</span> + strings.Join(params, <span class="string">&quot;, &quot;</span>) + <span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ASTNodeTypeNumberLiteral:</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ASTNodeTypeStringLiteral:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\&quot;&quot;</span> + node.value + <span class="string">&quot;\&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h2><p>最后把所有过程连起来：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compiler</span><span class="params">(input <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    tokens := Tokenizer(input)</span><br><span class="line">    ast := Parser(tokens)</span><br><span class="line">    newAst := Transformer(&amp;ast)</span><br><span class="line">    output := CodeGenerator(newAst)</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一小段测试代码，输入为 <code>(add 2 (subtract (add 3 5) 1))\n(print \&quot;hello world\&quot;)</code>，编译运行一下得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">2</span>, subtract(add(<span class="number">3</span>, <span class="number">5</span>), <span class="number">1</span>));</span><br><span class="line">print(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>完整代码在 <a target="_blank" rel="noopener" href="https://github.com/xnth97/Data-Structure-Notes/blob/master/tiny-compiler-go/compiler.go">这里</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然是个没有卵用的东西，不过从头撸的过程也能学习到现代编译器大致的工作原理。原项目 the-super-tiny-compiler 利用代码步步解释的形式也是让人耳目一新。另外 Golang 确实兼具 Python 易学的语法、强大的标准库和 C 的底层操作能力，比我想象的要香，看来可以当 gopher 了。</p>

    </section>
    <footer class="post-footer">
      <section class="author">
  <h4>Yubo Qin</h4>
  <p>真不错</p>
</section>
      <section class="share">
  <h4>分享这篇文章</h4>
  <a target="_blank" rel="noopener" href='https://www.linkedin.com/sharing/share-offsite/?url=https://xnth97.github.io/2020/05/29/tiny-compiler/' onclick="window.open(this.href, 'linkedin-share', 'width=720,height=480');return false;">
    <svg class='icon'>
      <use xlink:href='#icon-linkedin'></use>
    </svg>
    <span class='hidden'>LinkedIn</span>
  </a>
  <a target="_blank" rel="noopener" href='http://service.weibo.com/share/share.php?appkey=&title=用 Golang 撸一个玩具编译器&url=https://xnth97.github.io/2020/05/29/tiny-compiler/&pic=&searchPic=false&style=simple' onclick="window.open(this.href, 'weibo-share', 'width=640,height=360');return false;">
    <svg class='icon'>
      <use xlink:href='#icon-sina-weibo'></use>
    </svg>
    <span class='hidden'>Sina Weibo</span>
  </a>
  <a target="_blank" rel="noopener" href='http://twitter.com/share?url=https://xnth97.github.io/2020/05/29/tiny-compiler/'
    onclick="window.open(this.href, 'twitter-share', 'width=640,height=480');return false;">
    <svg class="icon">
      <use xlink:href="#icon-twitter"></use>
    </svg>
    <span class="hidden">Twitter</span>
  </a>
  <a target="_blank" rel="noopener" href='https://www.facebook.com/sharer/sharer.php?u=https://xnth97.github.io/2020/05/29/tiny-compiler/'
    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
    <svg class="icon">
      <use xlink:href="#icon-facebook2"></use>
    </svg>
    <span class="hidden">Facebook</span>
  </a>
</section>
    </footer>
  </article>
  <nav class="pagination" role="pagination">
  
  <a class="newer-posts" href="/2020/11/03/digital-home-2020/">
    ← 数字家庭二零二零
  </a>
  
  <span class="page-number">•</span>
  
  <a class="older-posts" href="/2020/01/16/2019-annual/">
    2019 的一些碎片 →
  </a>
  
</nav>
  <div id="comment" class="comments-area">
  <div id="disqus_thread"></div>
  <script>
    // var disqus_config = function () {
    // this.page.url = page.permalink;  // Replace PAGE_URL with your page's canonical URL variable
    // this.page.identifier = page.title; // Replace PAGE_IDENTIFIER with your page'sunique identifier variable
    // };
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://xnth97.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js"></script>
<script>
  mediumZoom(document.querySelectorAll('.post-content img'));
</script>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">2022 &copy; Yubo Qin &bull; <a href="/about">关于我</a></section>
  </div>
</footer>

  
</body>
</html>
